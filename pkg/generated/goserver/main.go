// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Diary - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 0.0.1
 * Contact: ilya.korolev@outlook.com
 */

package goserver

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/gorilla/mux"

	"github.com/ya-breeze/diary.be/pkg/config"
)

type CustomControllers struct {
	AssetsAPIService AssetsAPIService
	AuthAPIService   AuthAPIService
	ItemsAPIService  ItemsAPIService
	SyncAPIService   SyncAPIService
	UserAPIService   UserAPIService
}

func Serve(ctx context.Context, logger *slog.Logger, cfg *config.Config,
	controllers CustomControllers, extraRouters []Router, middlewares ...mux.MiddlewareFunc) (net.Addr, chan int, error) {
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Port))
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to listen: %w", err)
	}
	logger.Info(fmt.Sprintf("Listening at port %d...", listener.Addr().(*net.TCPAddr).Port))

	AssetsAPIService := NewAssetsAPIService()
	if controllers.AssetsAPIService != nil {
		AssetsAPIService = controllers.AssetsAPIService
	}
	AssetsAPIController := NewAssetsAPIController(AssetsAPIService)

	AuthAPIService := NewAuthAPIService()
	if controllers.AuthAPIService != nil {
		AuthAPIService = controllers.AuthAPIService
	}
	AuthAPIController := NewAuthAPIController(AuthAPIService)

	ItemsAPIService := NewItemsAPIService()
	if controllers.ItemsAPIService != nil {
		ItemsAPIService = controllers.ItemsAPIService
	}
	ItemsAPIController := NewItemsAPIController(ItemsAPIService)

	SyncAPIService := NewSyncAPIService()
	if controllers.SyncAPIService != nil {
		SyncAPIService = controllers.SyncAPIService
	}
	SyncAPIController := NewSyncAPIController(SyncAPIService)

	UserAPIService := NewUserAPIService()
	if controllers.UserAPIService != nil {
		UserAPIService = controllers.UserAPIService
	}
	UserAPIController := NewUserAPIController(UserAPIService)

	routers := append(extraRouters, AssetsAPIController, AuthAPIController, ItemsAPIController, SyncAPIController, UserAPIController)
	router := NewRouter(routers...)

	router.Use(middlewares...)

	// Parse allowed origins from config (comma-separated)
	allowedOrigins := []string{"http://localhost:3000"}
	if cfg.AllowedOrigins != "" {
		allowedOrigins = strings.Split(cfg.AllowedOrigins, ",")
		// Trim whitespace from each origin
		for i := range allowedOrigins {
			allowedOrigins[i] = strings.TrimSpace(allowedOrigins[i])
		}
	}

	// Custom CORS middleware that properly handles credentials
	corsMiddleware := createCORSMiddleware(allowedOrigins)

	server := &http.Server{
		Handler: corsMiddleware(router),
	}

	go func() {
		server.Serve(listener)
	}()

	finishChan := make(chan int, 1)
	go func() {
		<-ctx.Done()
		logger.Info("Shutting down server...")
		timeout, _ := context.WithTimeout(context.Background(), 5*time.Second)
		server.Shutdown(timeout)
		finishChan <- 1
		logger.Info("Server stopped")
	}()

	return listener.Addr(), finishChan, nil
}

// createCORSMiddleware creates a CORS middleware that properly handles credentials
// and only allows specific origins (no wildcard fallback)
func createCORSMiddleware(allowedOrigins []string) func(http.Handler) http.Handler {
	allowedOriginsMap := make(map[string]bool)
	for _, origin := range allowedOrigins {
		allowedOriginsMap[origin] = true
	}

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			origin := r.Header.Get("Origin")

			// Check if origin is in allowed list
			if origin != "" && allowedOriginsMap[origin] {
				// Set CORS headers for allowed origins
				w.Header().Set("Access-Control-Allow-Origin", origin)
				w.Header().Set("Access-Control-Allow-Credentials", "true")
				w.Header().Set("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, DELETE, OPTIONS")
				w.Header().Set("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, Authorization")
			}

			// Handle preflight requests
			if r.Method == "OPTIONS" {
				w.WriteHeader(http.StatusOK)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}
